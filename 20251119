import org.apache.hadoop.hive.ql.exec.UDF;
import javax.xml.bind.DatatypeConverter;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;

public class HexToKorSafe extends UDF {
    // MS949 디코더 준비 (매번 생성하지 않게 static 처리)
    private static final Charset CHARSET_MS949 = Charset.forName("MS949");

    public String evaluate(String hexStr) {
        if (hexStr == null) return null;

        try {
            // 1. Hex -> Byte 변환
            byte[] bytes = DatatypeConverter.parseHexBinary(hexStr);

            // 2. 디코더 설정 (가장 중요!)
            // 클릭하우스와 동일하게 동작하도록 "에러 발생 시 대체 문자()로 치환" 설정
            CharsetDecoder decoder = CHARSET_MS949.newDecoder();
            decoder.onMalformedInput(CodingErrorAction.REPLACE);       // 뭉개진 입력
            decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);  // 매핑 없는 문자
            
            // 필요하다면 대체 문자를 "?"로 바꿀 수도 있음 (클릭하우스 설정에 따라)
            // decoder.replaceWith("?"); 

            // 3. 변환 수행
            ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);
            CharBuffer charBuffer = decoder.decode(byteBuffer);

            return charBuffer.toString();

        } catch (Exception e) {
            // Hex 형식이 아예 틀린 경우(홀수 길이 등)에는 null 반환
            return null;
        }
    }
}


-----------------------------------------------------------------------------------------------------------------------------------------------------------

package com.example.impala.udf;

import org.apache.hadoop.hive.ql.exec.UDF;
import org.apache.hadoop.io.Text;

import java.nio.charset.Charset;

/**
 * HEX 로 표현된 MS-949 바이트를 UTF-8 STRING 으로 디코딩하는 UDF
 * 입력:  STRING  (예: "B0A1B0A2" 또는 "0xB0A1B0A2")
 * 출력: STRING  (Impala 내부는 UTF-8)
 */
public class Ms949HexToUtf8 extends UDF {

    private static final Charset MS949 = Charset.forName("MS949");

    public Text evaluate(Text hexText) {
        if (hexText == null) {
            return null;
        }
        String hex = hexText.toString().trim();
        if (hex.isEmpty()) {
            return new Text("");
        }

        // 0x / 0X prefix 제거
        if (hex.startsWith("0x") || hex.startsWith("0X")) {
            hex = hex.substring(2);
        }

        // 길이가 홀수면 마지막 한 글자 버림 (원하면 예외 던지도록 수정 가능)
        if ((hex.length() & 1) == 1) {
            hex = hex.substring(0, hex.length() - 1);
        }

        byte[] bytes = hexStringToBytes(hex);
        String decoded = new String(bytes, MS949);  // MS-949 바이트 → 문자열
        return new Text(decoded);                   // Impala/Hive 에서는 UTF-8 로 처리
    }

    private static byte[] hexStringToBytes(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];

        for (int i = 0; i < len; i += 2) {
            int hi = Character.digit(s.charAt(i), 16);
            int lo = Character.digit(s.charAt(i + 1), 16);

            if (hi == -1 || lo == -1) {
                // 잘못된 HEX 문자면 0으로 (필요하면 예외 던지도록 변경 가능)
                data[i / 2] = 0;
            } else {
                data[i / 2] = (byte) ((hi << 4) + lo);
            }
        }
        return data;
    }
}
