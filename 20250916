WITH main_data AS ( 
SELECT * FROM 
( 
SELECT * FROM TEST UNION ALL SELECT * FROM TEST2 
) 
WHERE occr_date BETWEEN '2025-03-01' AND '2025-03-31' 
AND STRTITLE = 'abc' 
-- EXPT_STR_YN: TEST_LOG에 PKT_SEQ 있으면 Y → 
AND if(dictHas('dict_excluded_pkt_seq', PKT_SEQ), 'Y', NULL) != 'Y' 
) 
SELECT *
         , if(dictHas('dict_excluded_pkt_seq', PKT_SEQ), 'Y', 'N') AS EXPT_STR_YN 
  FROM main_data; 

WITH main_data AS ( 
SELECT OCCR_DT, STRTITLE, MAX(SIP) SIP, MAX(DIP) DIP
    , DENSE_RANK OVER(PARTITION BY STRTITLE ORDER BY OCCR_DT DESC) DR 
FROM 
( 
SELECT * FROM TEST UNION ALL SELECT * FROM TEST2 
) 
WHERE OCCR_DT BETWEEN '2025-03-01' AND '2025-03-31' 
    AND STRTITLE = 'abc' 
-- EXPT_STR_YN: TEST_LOG에 PKT_SEQ 있으면 Y → 
AND if(dictHas('dict_excluded_pkt_seq', PKT_SEQ), 'Y', NULL) != 'Y'
 GROUP BY OCCR_DT, STRTITLE 
) SELECT STRTITLE, MAX(OCCR_DT),MAX(DIP),MAX(SIP) FROM main_data WHERE DR = 1 ;


WITH base AS (
  SELECT PKT_SEQ, OCCR_DT, STRTITLE, SIP, DIP
  FROM
  (
    SELECT * FROM TEST
    UNION ALL
    SELECT * FROM TEST2
  )
  PREWHERE OCCR_DT BETWEEN '2025-03-01' AND '2025-03-31'
    AND STRTITLE = 'abc'
  WHERE NOT dictHas('dict_excluded_pkt_seq', PKT_SEQ)
),
per_day AS (
  SELECT STRTITLE, OCCR_DT, max(SIP) AS max_sip, max(DIP) AS max_dip
  FROM base
  GROUP BY STRTITLE, OCCR_DT
),
last_dt AS (
  SELECT STRTITLE, max(OCCR_DT) AS last_occr_dt
  FROM per_day
  GROUP BY STRTITLE
)
SELECT p.STRTITLE, p.OCCR_DT AS last_occr_dt, p.max_dip, p.max_sip
FROM per_day p
ANY INNER JOIN last_dt l USING (STRTITLE)
WHERE p.OCCR_DT = l.last_occr_dt;



/* 
  목표: 윈도우(DENSE_RANK) 없이도 
  STRTITLE마다 가장 최근 OCCR_DT의 레코드(그 날짜의 max(DIP), max(SIP))를 빠르게 구하기
*/

WITH base AS (
  SELECT
    PKT_SEQ, OCCR_DT, STRTITLE, SIP, DIP
  FROM (
    SELECT * FROM TEST
    UNION ALL
    SELECT * FROM TEST2
  )
  /* PREWHERE: 대용량 테이블에서 먼저 강한 조건을 푸시다운해 I/O 감소 */
  PREWHERE OCCR_DT BETWEEN '2025-03-01' AND '2025-03-31'
    AND STRTITLE = 'abc'
    /* dictHas 대신 1회성 해시-셋을 만드는 NOT IN으로 치환 (행마다 사전 조회 X) */
    AND PKT_SEQ NOT IN (SELECT pkt_seq FROM dict_excluded_pkt_seq_src)
),

per_day AS (
  /* 날짜별로 먼저 집계: 그 날의 최대 SIP/DIP를 구해 두기 */
  SELECT
    STRTITLE,
    OCCR_DT,
    max(SIP) AS max_sip,
    max(DIP) AS max_dip
  FROM base
  GROUP BY STRTITLE, OCCR_DT
)

/*
  핵심 아이디어:
  - argMax(V, K): K(키)가 최대일 때의 V(값)를 돌려주는 집계 함수
  - 여기서는 V를 (OCCR_DT, max_dip, max_sip) '튜플'로 묶고,
    K는 OCCR_DT로 주면, "가장 최근 날짜"에 해당하는 튜플을 통째로 얻을 수 있음.
  - 정렬이나 윈도우 없이 집계만으로 해결 → 빠름.
*/
SELECT
  STRTITLE,
  /* tupleElement(t, N): 튜플 t의 N번째 원소를 꺼냄 (ClickHouse는 1-based 인덱스) */
  tupleElement(t, 1) AS last_occr_dt,   -- 튜플의 1번째 = OCCR_DT
  tupleElement(t, 2) AS max_dip,        -- 튜플의 2번째 = max_dip
  tupleElement(t, 3) AS max_sip         -- 튜플의 3번째 = max_sip
FROM (
  SELECT
    STRTITLE,
    /* 
      argMax(tuple(...), OCCR_DT):
      - OCCR_DT가 가장 큰(=가장 최근) 레코드의 튜플 (OCCR_DT, max_dip, max_sip)을 반환
      - tie가 있으면 첫 번째로 만난 것을 사용 (보통 동일 날짜면 문제 없음)
    */
    argMax(tuple(OCCR_DT, max_dip, max_sip), OCCR_DT) AS t
  FROM per_day
  GROUP BY STRTITLE
);


/* 25.x에서 그대로 동작 */

WITH base AS (
  /* 각 테이블에서 먼저 강한 조건을 푸시다운 */
  SELECT PKT_SEQ, OCCR_DT, STRTITLE, SIP, DIP
  FROM TEST
  PREWHERE OCCR_DT BETWEEN '2025-03-01' AND '2025-03-31'
    AND STRTITLE = 'abc'
    AND PKT_SEQ NOT IN (SELECT pkt_seq FROM dict_excluded_pkt_seq_src)   -- dictHas 대체
  UNION ALL
  SELECT PKT_SEQ, OCCR_DT, STRTITLE, SIP, DIP
  FROM TEST2
  PREWHERE OCCR_DT BETWEEN '2025-03-01' AND '2025-03-31'
    AND STRTITLE = 'abc'
    AND PKT_SEQ NOT IN (SELECT pkt_seq FROM dict_excluded_pkt_seq_src)
),
per_day AS (
  /* 날짜별로 먼저 집계: 그 날짜의 max SIP/DIP */
  SELECT
    STRTITLE,
    OCCR_DT,
    max(SIP) AS max_sip,
    max(DIP) AS max_dip
  FROM base
  GROUP BY STRTITLE, OCCR_DT
)
SELECT
  STRTITLE,
  /* = MAX(DIP) KEEP (DENSE_RANK LAST ORDER BY OCCR_DT) */
  argMax(max_dip, (OCCR_DT, max_dip)) AS max_dip_at_last_dt,
  /* = MAX(SIP) KEEP (DENSE_RANK LAST ORDER BY OCCR_DT) */
  argMax(max_sip, (OCCR_DT, max_sip)) AS max_sip_at_last_dt,
  /* 참고용: 마지막 날짜 자체 */
  argMax(OCCR_DT,  OCCR_DT)           AS last_occr_dt
FROM per_day
GROUP BY STRTITLE;


-- 동점 상황을 만들기 위해 같은 ts에 두 행 삽입
CREATE TABLE demo2
(
  strtitle String,
  ts       DateTime,
  sip      UInt32,
  dip      UInt32
) ENGINE = Memory;

INSERT INTO demo2 VALUES
('abc','2025-03-01 12:00:00',20,200),
('abc','2025-03-01 12:00:00',25,250),  -- ★ 같은 ts, sip가 더 큼
('xyz','2025-03-02 13:00:00',15,150);

-- Oracle: MAX(SIP) KEEP (DENSE_RANK LAST ORDER BY ts)
-- ClickHouse 동등: argMax(sip, (ts, sip))
SELECT
  strtitle,
  argMax(sip, (ts, sip)) AS max_sip_at_last_ts
FROM demo2
GROUP BY strtitle;

SET max_rows_in_set = 100000000;
SET max_bytes_in_set = '2GiB';


-- PKT_SEQ에서 월(YYYYMM)을 뽑아 담는 얇은 테이블
CREATE TABLE excluded_pkt_seq_monthly
(
  month   UInt32,   -- 예: 202503
  pkt_seq String
)
ENGINE = MergeTree
PARTITION BY month
ORDER BY (month, pkt_seq);


-- PKT_SEQ 왼쪽(언더스코어 앞)에서 월을 추출해서 실시간 적재
-- dt 파싱 실패 대비: 파싱되면 toYYYYMM(dt), 아니면 문자열 앞 6자리(YYYYMM)로 폴백
CREATE MATERIALIZED VIEW mv_excluded_pkt_seq_monthly
TO excluded_pkt_seq_monthly AS
SELECT
  -- '202509170961_252523' -> splitByChar('_', ...)[1] = '202509170961'
  -- 우선 베스트에포트 파싱 시도 → 성공: 해당 월, 실패: 앞 6자리로 월 추출
  coalesce(
    toYYYYMM(parseDateTimeBestEffortOrNull(splitByChar('_', pkt_seq)[1])),
    toUInt32(substring(splitByChar('_', pkt_seq)[1], 1, 6))
  ) AS month,
  pkt_seq
FROM TEST_LOG;

